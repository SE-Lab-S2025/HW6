# سیستم مدیریت پویای مصرف انرژی هوشمند در یک ساختمان اداری

این پروژه به عنوان بخشی از آزمایشگاه «الگوهای طراحی شیءگرا و بازآرایی کد» پیاده‌سازی شده است. هدف اصلی، طراحی و ساخت یک سیستم نرم‌افزاری برای مدیریت هوشمند و پویای مصرف انرژی در یک ساختمان اداری است. این سیستم قادر است وضعیت دستگاه‌های مختلف ساختمان (مانند سیستم گرمایشی، تهویه و روشنایی) را بر اساس سیاست‌های مختلف انرژی تغییر داده و هزینه مصرف را محاسبه کند.

برای پیاده‌سازی این سیستم، از دو الگوی طراحی کلیدی **Strategy** و **State** استفاده شده است.

---

## الگوهای طراحی استفاده شده

### ۱. الگوی طراحی Strategy (راهبرد) برای محاسبه هزینه انرژی

**چرا از این الگو استفاده شد؟**

بر اساس نیازمندی‌های پروژه، سیستم باید بتواند هزینه مصرف انرژی را بر اساس سیاست‌های تعرفه‌ای مختلف محاسبه کند. این سیاست‌ها شامل «تعرفه معمولی (Standard)»، «تعرفه زمان اوج مصرف (Peak Hours)» و «تعرفه سبز (Green Mode)» هستند. نکته مهم این است که این سیاست‌ها باید در زمان اجرای برنامه توسط مدیر ساختمان قابل تغییر باشند.

الگوی **Strategy** برای این سناریو ایده‌آل است، زیرا به ما اجازه می‌دهد تا هر یک از الگوریتم‌های محاسبه هزینه را در یک کلاس مجزا کپسوله کنیم. با این روش، کلاس اصلی مدیریت سیستم (Context) از جزئیات پیاده‌سازی هر الگوریتم مستقل باقی می‌ماند و می‌تواند به راحتی و در هر زمانی، الگوریتم محاسبه را تغییر دهد. این الگو اصل «جداسازی بخش‌های متغیر برنامه» را به خوبی پیاده‌سازی می‌کند.

**نحوه پیاده‌سازی:**

1.  **رابط `PricingStrategy`:**
    یک `interface` به نام `PricingStrategy` تعریف شد که دارای یک متد `calculateCost(int units)` است. این رابط، قراردادی را برای تمام کلاس‌های استراتژی تعریف می‌کند.

2.  **کلاس‌های پیاده‌ساز (Concrete Strategies):**
    سه کلاس مجزا این رابط را پیاده‌سازی کردند که هر کدام منطق محاسبه یکی از تعرفه‌ها را در خود دارند:
    * `StandardPricingStrategy`: هزینه هر واحد انرژی را ۵۰۰ تومان محاسبه می‌کند.
    * `PeakHoursPricingStrategy`: هزینه هر واحد انرژی را ۱۰۰۰ تومان محاسبه می‌کند.
    * `GreenModePricingStrategy`: هزینه هر واحد انرژی را ۳۰۰ تومان محاسبه می‌کند.

3.  **کلاس `EnergyManagementSystem` (Context):**
    این کلاس اصلی، یک مرجع (reference) به `PricingStrategy` نگه می‌دارد. هنگامی که متد محاسبه هزینه (`calculateEnergyCost`) در این کلاس فراخوانی می‌شود، این کلاس مسئولیت محاسبه را به شیء استراتژی فعلی خود واگذار (delegate) می‌کند. با استفاده از متد `setPricingStrategy`، مدیر سیستم می‌تواند در هر لحظه استراتژی محاسبه هزینه را تغییر دهد.

### ۲. الگوی طراحی State (حالت) برای مدیریت وضعیت سیستم

**چرا از این الگو استفاده شد؟**

سیستم انرژی ساختمان می‌تواند در یکی از سه حالت مشخص قرار بگیرد: «فعال (Active)»، «اقتصادی (Eco Mode)» یا «خاموش (Shutdown)». رفتار سیستم، مانند دستگاه‌های فعال و پیام‌های وضعیت، بسته به حالت فعلی آن به طور کامل تغییر می‌کند.

الگوی **State** به یک شیء اجازه می‌دهد تا رفتار خود را هنگام تغییر حالت داخلی‌اش تغییر دهد، به طوری که به نظر می‌رسد کلاس شیء تغییر کرده است. این الگو ما را از نوشتن بلوک‌های شرطی بزرگ و تو در توی `if/else` یا `switch` در کلاس اصلی برای مدیریت رفتارهای وابسته به حالت، بی‌نیاز می‌کند. به جای آن، تمام منطق مربوط به یک حالت خاص، در یک کلاس مجزا کپسوله می‌شود.

**نحوه پیاده‌سازی:**

1.  **رابط `SystemState`:**
    یک `interface` به نام `SystemState` تعریف شد که متدی مانند `handleStateChange()` دارد. این متد، رفتارها و عملیات مربوط به هر حالت خاص (مانند چاپ پیام مناسب) را تعریف می‌کند.

2.  **کلاس‌های پیاده‌ساز (Concrete States):**
    سه کلاس مجزا این رابط را پیاده‌سازی کردند که هر کدام نماینده یکی از حالت‌های سیستم هستند:
    * `ActiveState`: نماینده حالتی است که در آن تمام سیستم‌های ساختمان روشن هستند.
    * `EcoState`: نماینده حالتی است که تنها سیستم‌های حیاتی (مانند روشنایی اضطراری و تهویه کم‌مصرف) روشن هستند.
    * `ShutdownState`: نماینده حالتی است که در آن تمام سیستم‌ها خاموش هستند.

3.  **کلاس `EnergyManagementSystem` (Context):**
    این کلاس یک مرجع به حالت فعلی سیستم (`currentState`) را در خود نگه می‌دارد. هر درخواستی که به این کلاس ارسال می‌شود و رفتارش وابسته به حالت است (مانند `getCurrentStatus`)، به شیء حالت فعلی واگذار می‌شود. تغییر حالت سیستم نیز با جایگزین کردن شیء حالت فعلی با یک نمونه از کلاس حالت جدید انجام می‌شود. برای مثال، برای تغییر حالت از `Active` به `Eco`، کافی است شیء `currentState` از یک نمونه `ActiveState` به یک نمونه `EcoState` تغییر یابد.

---

## نحوه اجرای برنامه

پروژه با استفاده از Maven مدیریت می‌شود. برای اجرای برنامه، متد `main` در کلاس `Main.java` را اجرا کنید. برنامه در حالت اولیه `Active` و با تعرفه `Standard` شروع به کار می‌کند. سپس یک منوی تعاملی برای کاربر نمایش داده می‌شود که از طریق آن می‌توان وضعیت‌ها و سیاست‌ها را تغییر داد، هزینه را شبیه‌سازی کرد یا از برنامه خارج شد.

---

<div dir="rtl">

## پاسخ سوالات

### ۱)

1. **الگوهای ساختاری (Creational Patterns):** این الگوها به فرآیند ساخت و ایجاد اشیاء کمک می‌کنند و هدفشان جدا کردن فرآیند ساخت از استفاده از اشیاء است. به عبارت دیگر، الگوهای ساختاری نحوه ایجاد اشیاء را بر اساس نیازهای مختلف سیستم مدیریت می‌کنند.

2. **الگوهای ساختاری (Structural Patterns):** این الگوها به ترکیب و ساخت ساختارهای پیچیده از اشیاء و کلاس‌ها می‌پردازند. هدف آنها بهبود سازماندهی ساختار سیستم است و اغلب برای مدیریت ارتباطات پیچیده بین اجزاء استفاده می‌شوند.

3. **الگوهای رفتاری (Behavioral Patterns):** این الگوها نحوه تعامل و ارتباط بین اشیاء را مدیریت می‌کنند و تمرکزشان بر روی رفتار و ارتباطات است. این الگوها به طور خاص بر نحوه انجام عملیات‌ها و ارتباطات میان اجزاء سیستم متمرکزند.

---

### ۲)

در فاز اول آزمایش، الگوهای استفاده شده در دسته **الگوهای ساختاری** و **الگوهای رفتاری** قرار دارند، چرا که بیشتر تمرکز بر روی نحوه مدیریت رفتار سیستم و همچنین تعامل بین اجزاء سیستم بوده است. این الگوها برای مدیریت ارتباطات بین اجزاء مختلف و همچنین برای مدیریت تغییرات وضعیت سیستم مورد استفاده قرار گرفته‌اند.

---

### ۳)

1. **الگوی ساختاری (Creational Pattern):** الگوهایی مانند **Factory Method** می‌توانند برای انتخاب مناسب‌ترین سیاست‌ها بر اساس وضعیت سیستم استفاده شوند. این الگو به سیستم این امکان را می‌دهد که یک شیء جدید را ایجاد کند که به شرایط خاص تغییرات سازگار است، مانند انتخاب سیاست‌های هزینه‌ای متناسب با حالت‌های مختلف سیستم (مثل Eco Mode، Active و Shutdown).

2. **الگوی رفتاری (Behavioral Pattern):** الگوهایی مانند **Strategy Pattern** می‌توانند برای انتخاب سیاست‌های مختلف هزینه براساس وضعیت سیستم به کار روند. این الگو به سیستم این امکان را می‌دهد که به طور دینامیک یکی از استراتژی‌های محاسبه هزینه را بر اساس وضعیت موجود انتخاب کند.

---

### ۴)

الگوی **Factory Method** یکی از الگوهای طراحی است که در اصل جزء اصول SOLID در طراحی نرم‌افزار قرار دارد. در این الگو، هر کلاس مسئول ایجاد شیء خود نیست و به جای آن این کار به یک متد یا کلاس دیگر واگذار می‌شود. این طراحی به ما این امکان را می‌دهد که فرآیند ساخت شیء را از دیگر عملیات‌ها جدا کنیم. در نتیجه کد ما انعطاف‌پذیرتر می‌شود و تغییرات در ساخت شیء باعث نمی‌شود که کدهای دیگر آسیب ببینند.

- **اصل S (Single Responsibility Principle):** متدهای کارخانه‌ای که در الگوی Factory Method استفاده می‌شوند، تنها مسئول ایجاد اشیاء هستند و مسئولیت‌های دیگری ندارند. این باعث می‌شود کد تمیزتر و قابل نگهداری‌تر باشد.
  
- **اصل O (Open/Closed Principle):** این الگو به ما این امکان را می‌دهد که بدون تغییر در کد موجود، کارخانه‌های جدیدی برای ایجاد اشیاء جدید به سیستم اضافه کنیم.

- **اصل L (Liskov Substitution Principle):** در الگوی Factory Method، برای ایجاد اشیاء از کلاس‌های مشتق شده استفاده می‌شود و این کلاس‌ها باید قابلیت جایگزینی با کلاس پایه خود را داشته باشند.

- **اصل I (Interface Segregation Principle):** در این الگو، ممکن است رابط‌هایی برای کلاس‌ها تعریف شود که تنها شامل متدهای مرتبط با ایجاد اشیاء باشد، بنابراین هر کلاس فقط متدهای مورد نیاز خود را پیاده‌سازی می‌کند.

- **اصل D (Dependency Inversion Principle):** با استفاده از الگوی Factory Method، وابستگی‌ها به جای اینکه در درون کلاس‌ها ساخته شوند، از بیرون تأمین می‌شوند و این امر باعث می‌شود کد انعطاف‌پذیرتر و قابل تست‌تر باشد.

---

### ۵)

- **کد تمیز:** کدی ساده و خوانا با نام‌گذاری درست، توابع کوتاه و حداقل تکرار که به‌راحتی قابل‌تست و تغییر است.  
- **بدهی فنی:** هزینهٔ آینده‌ای که به‌دلیل میان‌بُرهای امروز (مثل عدم تست یا طراحی ضعیف) ایجاد می‌شود و با «بهرهٔ نگه‌داری» در طول زمان پرداخت می‌گردد.  
- **بوی بد (Code Smell):** نشانهٔ سطحیِ ایراد در طراحی/پیاده‌سازی (مثل متد خیلی بلند، کلاس چاق، کد تکراری) که باگ نیست ولی هشدارِ نیاز به بازآرایی است.

---

### ۶)

* **Bloaters (بادکرده‌ها)**: کد/کلاس/متدی که بیش از حد بزرگ شده و کار با آن سخت است؛ نمونه‌های رایج: *Long Method*، *Large Class*، *Primitive Obsession*، *Long Parameter List* و *Data Clumps*. ([Refactoring Guru][1])
* **Object-Orientation Abusers (سوء‌استفاده از شیء‌گرایی)**: کاربرد ناقص اصول OOP؛ مثل *Switch Statements* طولانی، *Temporary Field* و *Refused Bequest*. ([Refactoring Guru][2])
* **Change Preventers (تغییر-بازدارها)**: هر تغییری در یک نقطه، شما را مجبور به تغییرات متعدد در جاهای دیگر می‌کند؛ مانند *Divergent Change* و *Shotgun Surgery* و *Parallel Inheritance Hierarchies*. ([Refactoring Guru][3])
* **Dispensables (قابل‌حذف‌ها)**: چیزهای زائدی که نبودشان کد را خواناتر و ساده‌تر می‌کند؛ مثل *Duplicate Code*، *Lazy Class*، *Data Class*، *Dead Code* و… . ([Refactoring Guru][4])
* **Couplers (کوپلِرها/وابسته‌ها)**: بوی بد ناشی از وابستگی زیاد بین کلاس‌ها؛ شامل *Feature Envy*، *Inappropriate Intimacy*، *Message Chains* و *Middle Man*. ([Refactoring Guru][1])

---

### ۷)

**الف)** این بو در گروه **Couplers** قرار می‌گیرد. 

**ب)** بازآرایی‌های پیشنهادی برای رفع آن:

* **Move Method** (انتقال متدی که بیش از داده‌های کلاس دیگر استفاده می‌کند).
* **Extract Method** (اگر فقط بخشی از متد به داده‌های کلاس دیگر «حسادت» دارد، آن بخش را جدا و منتقل کنید).
* گاهی **Move Field** یا **Extract Class** نیز مفید است تا داده و رفتار مرتبط کنار هم باشند. 

**ج)** چه زمانی می‌توان نادیده‌اش گرفت؟

* وقتی طراحیِ عمدی، رفتار را از داده جدا کرده تا **بتوان رفتار را پویا عوض کرد** (الگوهایی مثل **Strategy** و **Visitor**).
* وقتی متد به‌صورت منطقی یک «سرویس» مستقل است و چسباندنش به مدل، **انسجام را بدتر** می‌کند. 

---

###  ۸)

مخزن: `bigsheykh/Convert_UML_to_ANSI_C`
برای هر مورد مسیر فایل/نشانه، شرح بو و پیشنهاد رفع آمده است (به استناد کامیت‌های پیوند داده‌شده):

1. **Feature Envy + Magic Numbers در GUI**
   `src/com/project/diagramGUI/GUITextFieldSetter.java`، متد `inputChecker()` چندین بار متدهای `LexicalAnalyzer` را صدا می‌زند و برای رنگ‌ها اعداد جادویی دارد.
   پیشنهاد: ساخت متدی مانند `LexicalAnalyzer.classify(text)` و تعریف ثابت‌های رنگ. 

2. **Duplicate Code / تکرار اعتبارسنجی نام کلاس**
   `src/com/project/classBaseUML/ClassStructure.java`، در `statusOfMember()` و `getAllProblems()` شرط‌های یکسان برای اعتبار نام کلاس/ابرکلاس تکرار شده‌اند.
   پیشنهاد: استخراج متد مشترک `validateNames()` یا یک **Validator** مستقل. 

3. **Data Clumps / زوج‌های تکرارشونده**
   بازگشت‌های مکرر از نوع `Pair<BasicDiagramStatus, LinkedList<String>>` در همان کلاس‌ها، یعنی داده‌های هم‌سفره‌ای که همه‌جا با هم حرکت می‌کنند.
   پیشنهاد: ساخت کلاس دامنه‌ای مثل `StatusReport`. 

4. **Large/Utility Class در لایه واژه‌کاوی**
   `src/com/project/lexicalAnalyzer/LexicalAnalyzer.java` شامل توابع استاتیک زیاد و جزئیات سطح پایین (همراه با ثابت‌ها که بعداً به `CLanguageTokens` منتقل شده‌اند).
   پیشنهاد: تفکیک به چند سرویس کوچک‌تر (Validation، Parsing، Tokens). 

5. **Long/Low-Level Method**
   همان فایل، متدی مثل `getWithoutArrayBracket(...)` هم حلقه دارد هم بازگشت و هم تطبیق Regex؛ نشانه‌ای از جزئیات زیاد در یک متد.
   پیشنهاد: **Extract Method** به قطعات کوچک‌تر (یافتن نماهای `[]`، اعتبار طول، تبدیل رشته). 

6. **Primitive Obsession در نمایش نوع‌ها**
   `src/com/project/classBaseUML/ValueType.java` از `String typeName` و `int numberOfPointer` برای مدل‌سازی نوع/تعداد اشاره‌گر استفاده شده است.
   پیشنهاد: کلاس غنی مثل `TypeRef{BaseType, PointerDepth, ArrayDims...}` یا **Replace Data Value with Object**. 

7. **Raw Types / استفاده از Vector خام**
   `src/com/project/phase1CodeGeneration/CompleteClass.java`، امضای `modifyByParents(String className, Vector diagram, int counter)` از جنریک‌ها استفاده نمی‌کند.
   پیشنهاد: استفاده از `List<...>`/`Vector<...>` جنریک و ترجیحاً `List` به‌جای `Vector`. 

8. **Data Class (کلاس صرفاً داده‌ای) داخل MethodOverloader**
   کلاس داخلی `RealFunction` فقط فیلد دارد و هیچ رفتاری جز سازنده ندارد.
   پیشنهاد: افزودن رفتار مرتبط (مثلاً تطبیق امضا/پارامترها) یا تبدیل به `record`. 

9. **Magic Number در تولید نام تصادفی**
   `MethodOverloader.randomGenerator()` طول ۱۰ کاراکتری را هاردکُد کرده است.
   پیشنهاد: ثابت `ID_LENGTH = 10` و تزریق/پیکربندی در تست‌ها. 

10. **Large Class / سازنده‌سازیرشته‌ای در تولید کد فاز۱**
    کلاس‌های تولید کد مانند `CompleteConstructor` و `Phase1CodeGenerator`، متدهای طولانی برای ساخت رشته‌های خروجی دارند (ترکیب نام‌ها/علائم).
    پیشنهاد: به‌کارگیری **Builder**های کوچک‌تر یا **Extract Class/Method** برای هر قطعه (امضای سازنده، بدنه new، مقدار بازگشتی و…).
    
---

###  ۹)
در انتها، **formatter** در سی‌ام‌اس می‌تواند به کدنویس‌ها کمک کند تا کدهای خود را با ساختار مشخص و مرتب بنویسند. این ابزار به‌طور خودکار قالب‌بندی کد را انجام می‌دهد و آن را برای خوانایی بهتر و رعایت قوانین برنامه‌نویسی استاندارد تنظیم می‌کند. علاوه بر این، استفاده از **formatter** ارتباطی با بازآرایی کد دارد زیرا با قالب‌بندی صحیح، کدها خواناتر شده و درک آن‌ها برای توسعه‌دهندگان راحت‌تر می‌شود. یکی از ابزارهای معروف در این زمینه **Maven Formatter Plugin** است که به‌طور خودکار کدهای Java را طبق قواعد استاندارد قالب‌بندی می‌کند.

</div>